shader FuseCommonNoiseSine
{
	////////////////////////////////////////////////////////////////
	//
	//          Sine Basis
	// 
	////////////////////////////////////////////////////////////////

	// just for study, but can in fact be a usefel cheap basis.  

	// 1D
	float sineNoise (float p)
	{
		return sin(p*2.);
	}

	// 2D
	float sineNoise (float2 p)
	{
		float2 s = sin(p*2.);

		return dot(s.x,s.y);
	}

	// 3D
	float sineNoise (float3 p)
	{
		float3 s = sin(p*2.);
		return dot(dot(s.x, s.y), s.z);
	}

	// 4D
	float sineNoise (float4 p)
	{
		float4 s = sin(p*2.);
		return dot(dot(dot(s.x, s.y), s.z), s.w);
	}

	// 3D with gradient
	// TODO Replace with analytic 
	float4 sineNoiseGrad (float3 p)
	{
		float n = sineNoise(p);
		float3  result = n.xxx;
		float e = 0.001;
		for(int i = 0; i < 3; i++) 		// just a weird ass way of writing forward difference
		{
			float3 offset = .0;
			offset[i] = e;
			result[i] = (sineNoise(p + offset) -  result[i]) /  e;
		}
	   return float4(n, result);

	}

};