shader FuseCommonDrawSphereSimpleExtension_ShaderFX : ShaderBaseStream, TransformationBase, Transformation, PositionStream4, NormalStream, Texturing, ShadingBase, ShaderUtils
{
	compose SphereProvider Provider;

	stage stream float sphereSize;
    stage stream float3 spherePos;

	// End of the VS (usually skinning)
	stage override void PreTransformPosition() {}

	// End of tessellation (usually displacement mapping in world space, etc...)
	stage override void TransformPosition() {}

	// At the end of the geometry pipeline (to generate ShadingPosition)
	stage override void PostTransformPosition()
	{
		streams.ShadingPosition = streams.Position; // must be assigned to something
	}


		// custom geometry shader, quad particle in this case
	[maxvertexcount(4)]
	stage void GSMain(point Input input[1], inout TriangleStream<Output> triangleStream)
	{
		streams = input[0];

		// get data from ParticleProvider implementation
		streams.PositionWS = float4(Provider.getSpherePos(), 1);
		streams.sphereSize = Provider.getSphereSize();
		float4 posView = mul(streams.PositionWS, WorldView);

		for (int i=0; i<4; i++)
		{
			streams.TexCoord  = QuadUV[i].xy * 2 - 1; //center and scale for sphere impostor
			float4 viewCornerPos = float4(posView.xyz + QuadPositions[i].xyz * streams.sphereSize, 1);
			streams.ShadingPosition = mul(viewCornerPos, Projection);

			triangleStream.Append(streams);
		}     
	}


	//override shading, create sphere impostor in this case
	stage override float4 Shading() 
	{
		float2 mapping = streams.TexCoord;
		float lenSqr = dot(mapping, mapping);
		if (lenSqr > 1)
			discard; // Circles
		
		float z = sqrt(1 - lenSqr);

		float3 normal = float3(mapping, z);
		normal = normalize(mul(float4(normal, 0), ViewInverse).xyz);

		// code from VL.Stride help example
		// this seems to be using the acutal quad to write depth and normals etc, we want them to be from the sphere.  
		// note spheres are 100%  dark or light from shadows
		/*
		streams.normalWS = normal;
		streams.meshNormalWS = normal;

		float4 posQuad = streams.PositionWS;
		posQuad.z += z;
		float4 PosWVP = mul(posQuad, ViewProjection);
		streams.DepthVS = PosWVP.w;
		streams.DepthLessEqual = PosWVP.z/PosWVP.w;
		*/
		
		// new code to write pos & depth
		// Shadows look correct now, but if you move the camera a distance away have other weirdness
		// /*
		streams.PositionWS = float4((normal * streams.sphereSize) + streams.PositionWS.xyz, 1); //		pos = (normal * sphereRadius) + spherePos;
		float4 PosWVP = mul(streams.PositionWS, ViewProjection);
		streams.normalWS = normal;
		streams.meshNormalWS = normal;
		streams.Depth = PosWVP.z/PosWVP.w;
		// */

		return base.Shading();
	}
};