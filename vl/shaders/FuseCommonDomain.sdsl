shader FuseCommonDomain: FuseCoreMath
{

	////////////////////////////////////////////////////////////////
	//
	//             Coordinate Conversions
	//
	////////////////////////////////////////////////////////////////
	float2 polarToCart(float2 coords)
	{
		float mag = coords[1];
		float angle = -1.0 * coords[0] * 6.28319 + 1.57079633;

		coords[0] = mag * cos(angle);
		coords[1] = mag * sin(angle);
		return coords;
	}


	float2 cartToPolar (float2 v)
	{
		float2 result;
		float r;
		//r = length(v);
		r = v.x * v.x + v.y * v.y;
	
		if (r > 0)
		{
			r = sqrt(r);
			float angle = atan2(v.y, v.x);
			angle = -(angle+1.57079633)/6.28319;
			result = float2(angle,r);		
		}
		else
		{
			result = 0;
		}
		return result;
	}

	float3 Cart2Polar(float3 v)
	{
		float3 result;
		float r;
		//r = length(v);
		r = v.x * v.x + v.y * v.y + v.z * v.z;
	
		if (r > 0)
		{
			r = sqrt(r);
			float p, y;
			p = asin(v.y/r) / TWOPI;
			y = 0;
			if (v.z != 0) y = atan2(-v.x, -v.z);
			else if (v.x > 0) y = -PI / 2;
			else y = PI / 2;
			y /=  TWOPI;
			result = float3(p,y,r);		
		}
		else
		{
			result = 0;
		}
		return result;
	}

	float3 Polar2Cart(float3 v)
	{
	
		v.xy *= TWOPI;
		float cosp = -v.z * cos(v.x);
		float3 result = float3(cosp * sin(v.y), v.z * sin(v.x),cosp * cos(v.y));
		return result;
	}
	



	////////////////////////////////////////////////////////////////
	//
	//             Tile Coords
	//
	////////////////////////////////////////////////////////////////
	
	// Tile coords inspired by Amit Patel http://www-cs-students.stanford.edu/~amitp/game-programming/grids/

	#ifndef SQRT3
	#define SQRT3 1.7320508
	#endif

	// hex coords
	float2 worldToHex (float2 p)
	{
	  float3 c, r, dr;
	  c.xz = float2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);
	  c.y = - c.x - c.z;
	  r = floor (c + 0.5);
	  dr = abs (r - c);
	  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, 1.);
	  return r.xz;
	}

	float2 hexToWorld (float2 hex)
	{
	  return float2 (SQRT3 * (hex.x + 0.5 * hex.y), (3./2.) * hex.y);
	}

	float3 hexToCube(float2 hex)
	{
		float x = hex.x;
		float z = hex.y;
		float y = -x-z;
		return float3(x, y, z);
	}

	float2 cubeToHex(float3 cube)
	{
		return cube.xz;
	}

	float hexDistance(float2 hex1, float2 hex2)
	{
		float3 a =  hexToCube(hex1);
		float3 b =  hexToCube(hex2);
		return max(abs(a.x - b.x), max(abs(a.y - b.y), abs(a.z - b.z)));
	
	}


	// triangle coords
	float2 worldToTri(float2 p) 
	{
		p.x *= 5./3.;
		p = float2(p.x + p.y, -(p.x - p.y)); // shear pos
		float2 uv = frac(p);
		float isUp = (1-uv.y > uv.x);
		p = floor(p);
		p.y *= 2.;
		p.y += isUp;
		return p;
	}

	float2 triToWorld (float2 p)
	{
		float isUp = (p.y % 2 != 0);
		p.y  *= -.5;
		p = float2( (p.x - p.y), (p.x + p.y)); // unshear pos
		p = float2(p.y, p.x);
		p.x /= 5./3.;
		p *= .5;
		if(isUp) p += float2 (-.15, .58);  //fudged values!
		else p += float2(0, .666667);
		return p;
	}

	// box coords
	float2 worldToBox(float2 p) 
	{
		return floor(p);
	}

	float2 boxToWorld(float2 p)
	{
		return p+.5;
	}
};