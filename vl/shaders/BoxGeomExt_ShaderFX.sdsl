shader BoxGeomExt_ShaderFX : MaterialExtension , MaterialPixelStream 
{
    rgroup PerMaterial
    {
        stage StructuredBuffer<Particle> Particles;
    }

    cbuffer PerMaterial
    {
        

        stage float3 Size;

    }

    struct Particle
    {
        int Cycle;
        float Age;
        float3 Velocity;
        float3 Position;
        float4 Color;
        float Drag;
        float LifeTime;
        int Id;
        float3 AxisY;
        float3 AxisX;
        float3 AxisZ;
        float3 Size3;
    };

    stream uint VertexID : SV_VertexID;
    stream uint VID;
    stream bool Skip;

    static const float3 QuadPositions[24] = 
    {
        float3(-1, 1, 1),
        float3( 1, 1, 1),
        float3(-1,-1, 1),
        float3( 1,-1, 1),

        float3( 1, 1,-1),
        float3(-1, 1,-1),
        float3( 1,-1,-1),
        float3(-1,-1,-1),

        float3( 1, 1, 1),
        float3(-1, 1, 1),
        float3( 1, 1,-1),
        float3(-1, 1,-1),

        float3(-1,-1, 1),
        float3( 1,-1, 1),
        float3(-1,-1,-1),
        float3( 1,-1,-1),

        float3( 1,-1, 1),
        float3( 1, 1, 1),
        float3( 1,-1,-1),
        float3( 1, 1,-1),

        float3(-1, 1, 1),
        float3(-1,-1, 1),
        float3(-1, 1,-1),
        float3(-1,-1,-1),
    };

    static const float2 QuadUV[4] = 
    {
        float2(0,1), 
        float2(1,1),
        float2(0,0),
        float2(1,0)
    };

    stage override void PreTransformPosition()
    {
    }

    stage override void TransformPosition()
    {
    }

    stage override void PostTransformPosition()
    {
        streams.ShadingPosition = streams.Position;
        streams.VID = streams.VertexID;
        streams.Skip = false;
    }
/*
    stage override void ResetStream(){
        base.ResetStream();
        streams.matDiffuse = float4(1,0,0,1);
    }*/

    void SpawnQuad(uint start, inout TriangleStream<Output> triangleStream, float3 normal, Particle p)
    {
       for(uint i = start; i < start + 4; i++)
       {
            streams.TexCoord  = QuadUV[i % 4].xy;
            float4 posWorld = float4(p.Position, 1);
            posWorld.xyz += QuadPositions[i].x * p.AxisX * p.Size3.x;
            posWorld.xyz += QuadPositions[i].y * p.AxisY * p.Size3.y;
            posWorld.xyz += QuadPositions[i].z * p.AxisZ * p.Size3.z;
            
            posWorld = mul(posWorld, World);
            
            streams.PositionWS = posWorld;
            streams.normalWS = normal;

            float4 posView = mul(posWorld, View);
            streams.ShadingPosition = mul(posView, Projection);
            streams.DepthVS = streams.ShadingPosition.w;
            
            triangleStream.Append(streams);
        }

        triangleStream.RestartStrip();
    }

    [maxvertexcount(24)]
    stage void GSMain(point Input input[1], inout TriangleStream<Output> triangleStream)
    {
        streams = input[0];
        Particle p = Particles[streams.VID];
        if (streams.Skip) return;
        
        SpawnQuad(0, triangleStream, p.AxisZ, p);
        SpawnQuad(4, triangleStream, -p.AxisZ, p);
        SpawnQuad(8, triangleStream, p.AxisY, p);
        SpawnQuad(12, triangleStream, -p.AxisY, p);
        SpawnQuad(16, triangleStream, p.AxisX, p);
        SpawnQuad(20, triangleStream, -p.AxisX, p);
    }

    //override shading, create sphere impostor in this case
    stage override float4 Shading() 
    {
        
        //streams.matDiffuse = float4(1,0,1,1);
        //streams.matDiffuse = float4(1,0,0,1);//float3(1,0,1);
        return base.Shading();
        //return float4(1,0,0,1);
    }
};