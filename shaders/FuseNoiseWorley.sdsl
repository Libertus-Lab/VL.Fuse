shader FuseNoiseWorley : FuseHash
{
	/*
	Just a simple one first, that fits the interface of the general node.  Several nodes can deal with more advanded versions
	
	TODO:
	-Add F1F2
	-Add SmoothF1
	-Distance Metrics
	-F1 F2 combination Functions
	-Add Edge SDF
	-Add N-SPhere
	-Figure out how to support Feature struct output.  Eg for 3D:
		struct Worley3DFeature
		{
			float dist;
			float3 pos;
			float id;
		};
	*/ 

	// should be a delegate in patch
	float distFunc(float x, float y)
	{
		return abs(x - y);
	}

	float distFunc(float2 x, float2 y)
	{
		return distance(x, y);
		//return euclideanDist(x - y);
		//return chebyshevDist(x - y);
		//return minkowskiDist(x - y);
		//return cubesDist(x - y);
	}

	float distFunc(float3 x, float3 y)
	{
		return distance(x, y);
		//return euclideanDist(x - y);
		//return chebyshevDist(x - y);
		//return minkowskiDist(x - y);
		//return cubesDist(x - y);
	}

	float distFunc(float4 x, float4 y)
	{
		return distance(x, y);
		//return euclideanDist(x - y);
		//return chebyshevDist(x - y);
		//return minkowskiDist(x - y);
		//return cubesDist(x - y);
	}



	struct worley1DFeature
	{
		float dist;
		float pos;
		float id;
	};

	struct worley2DFeature
	{
		float dist;
		float2 pos;
		float id;
	};


	struct worley3DFeature
	{
		float dist;
		float3 pos;
		float id;
	};

	struct worley4DFeature
	{
		float dist;
		float4 pos;
		float id;
	};

	worley1DFeature makeWorleyFeature(float dist, float pos, float id)
	{
		worley1DFeature F;
		F.dist = dist; F.pos = pos; F.id = id;
		return F;
	}

	worley2DFeature makeWorleyFeature(float dist, float2 pos, float id)
	{
		worley2DFeature F;
		F.dist = dist; F.pos = pos; F.id = id;
		return F;
	}
	
	worley3DFeature makeWorleyFeature(float dist, float3 pos, float id)
	{
		worley3DFeature F;
		F.dist = dist; F.pos = pos; F.id = id;
		return F;
	}

	worley4DFeature makeWorleyFeature(float dist, float4 pos, float id)
	{
		worley4DFeature F;
		F.dist = dist; F.pos = pos; F.id = id;
		return F;
	}



	////////////////////////////////////////////////////////////////
	//
	//          Simple F1
	// 
	////////////////////////////////////////////////////////////////

	// 1D
	float worleySimpleNoise (float p, float jitter = .7)
	{
		float cellPosition = floor(p);
		float localPosition = p - cellPosition;
		float minDistance = 8.0;
		[unroll]
		for (int x = -1; x <= 1; x++) 
		{
			float cellOffset = x;
			float pointPosition = cellOffset + hash11(cellPosition + cellOffset) * jitter;
			float toCell = pointPosition - localPosition;
			float distanceToPoint = dot(toCell, toCell);
			if (distanceToPoint < minDistance) minDistance = distanceToPoint;		
		}
		return sqrt(minDistance);
	}

	// 2D
	float worleySimpleNoise (float2 p, float jitter = .7)
	{
		float2 cellPosition = floor(p);
		float2 localPosition = p - cellPosition;
		float minDistance = 8.0;
		[unroll]
		for (int y = -1; y <= 1; y++) 
		{
			[unroll]
			for (int x = -1; x <= 1; x++) 
			{
				float2 cellOffset = float2(x, y);
				float2 pointPosition = cellOffset + hash22(cellPosition + cellOffset) * jitter;
				float2 toCell = pointPosition - localPosition;
				float distanceToPoint = dot(toCell, toCell);
				if (distanceToPoint < minDistance) minDistance = distanceToPoint;		
			}
		}
		return sqrt(minDistance);
	}

	// 3D
	float worleySimpleNoise (float3 p, float jitter = .7)
	{
		float3 cellPosition = floor(p);
		float3 localPosition = p - cellPosition;
		float minDistance = 8.0;
		[unroll]
		for (int z = -1; z <= 1; z++) 
		{
			[unroll]
			for (int y = -1; y <= 1; y++) 
			{
				[unroll]
				for (int x = -1; x <= 1; x++) 
				{
					float3 cellOffset = float3(x, y, z);
					float3 pointPosition = cellOffset + hash33(cellPosition + cellOffset) * jitter;
					float3 toCell = pointPosition - localPosition;
					float distanceToPoint = dot(toCell, toCell);
					if (distanceToPoint < minDistance) minDistance = distanceToPoint;	
				}
			}
		}
		return sqrt(minDistance);
	}

	// 4D
	float worleySimpleNoise (float4 p, float jitter = .7)
	{
		float4 cellPosition = floor(p);
		float4 localPosition = p - cellPosition;
		float minDistance = 8.0;
		[unroll]
		for (int w = -1; w <= 1; w++) 
		{
			[unroll]
			for (int z = -1; z <= 1; z++) 
			{
				[unroll]
				for (int y = -1; y <= 1; y++) 
				{
					[unroll]
					for (int x = -1; x <= 1; x++) 
					{
						float4 cellOffset = float4(x, y, z, w);
						float4 pointPosition = cellOffset + hash44(cellPosition + cellOffset) * jitter;
						float4 toCell = pointPosition - localPosition;
						float distanceToPoint = dot(toCell, toCell);
						if (distanceToPoint < minDistance) minDistance = distanceToPoint;	
					}
				}
			}
		}
		return sqrt(minDistance);
	}


	////////////////////////////////////////////////////////////////
	//
	//          Smooth F1
	// 
	////////////////////////////////////////////////////////////////

	// adapted from IQ's 2d voronoise & blender voronoi node:
	// http://www.iquilezles.org/www/articles/voronoise/voronoise.htm	
	// https://github.com/blender/blender/blob/master/intern/cycles/kernel/shaders/node_voronoi_texture.osl
	
	// 1D
	worley1DFeature worleySmoothF1 (float p, float smooth = .2, float jitter = .7)
	{
		float cellPosition = floor(p);
		float localPosition = p - cellPosition;
		float smoothDistance  = 8.0;
		float smoothPosition = 0.0;
		float smoothID = 0.0;
		[unroll]
		for (int x = -1; x <= 1; x++) 
		{
			float cellOffset = x;
			float pointPosition = cellOffset + hash11(cellPosition + cellOffset) * jitter;
			float distanceToPoint = distFunc(pointPosition, localPosition);	
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (smoothDistance - distanceToPoint) / smooth);
			float correctionFactor = smooth * h * (1.0 - h);
			smoothDistance = lerp(smoothDistance, distanceToPoint, h) - correctionFactor;
			correctionFactor /= 1.0 + 3.0 * smooth;
			float cellID = hash11(cellPosition + cellOffset);
			smoothID = lerp(smoothID, cellID, h) - correctionFactor;
			smoothPosition = lerp(smoothPosition, pointPosition, h) - correctionFactor;
		}
		return makeWorleyFeature(smoothDistance, cellPosition + smoothPosition, smoothID);
	}



	// 2D
	worley2DFeature worleySmoothF1 (float2 p, float smooth = .2, float jitter = .7)
	{
		float2 cellPosition = floor(p);
		float2 localPosition = p - cellPosition;
		float smoothDistance  = 8.0;
		float2 smoothPosition = 0.0;
		float smoothID = 0.0;
		[unroll]
		for (int y = -1; y <= 1; y++) 
		{
			[unroll]
			for (int x = -1; x <= 1; x++) 
			{
				float2 cellOffset = float2(x, y);
				float2 pointPosition = cellOffset + hash22(cellPosition + cellOffset) * jitter;
				float distanceToPoint = distFunc(pointPosition, localPosition);
				float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (smoothDistance - distanceToPoint) / smooth);
				float correctionFactor = smooth * h * (1.0 - h);
				smoothDistance = lerp(smoothDistance, distanceToPoint, h) - correctionFactor;
				correctionFactor /= 1.0 + 3.0 * smooth;
				float cellID = hash12(cellPosition + cellOffset);
				smoothID = lerp(smoothID, cellID, h) - correctionFactor;
				smoothPosition = lerp(smoothPosition, pointPosition, h) - correctionFactor;
			}
		}
		return makeWorleyFeature(smoothDistance, cellPosition + smoothPosition, smoothID);
	}

	// 2D
	float2 worleySmoothF1_DEBUG (float2 p, float smooth = .2, float jitter = .7)
	{
		float2 cellPosition = floor(p);
		float2 localPosition = p - cellPosition;
		float smoothDistance  = 8.0;
		float2 smoothPosition = 0.0;
		float smoothID = 0.0;
		[unroll]
		for (int y = -1; y <= 1; y++) 
		{
			[unroll]
			for (int x = -1; x <= 1; x++) 
			{
				float2 cellOffset = float2(x, y);
				float2 pointPosition = cellOffset + hash22(cellPosition + cellOffset) * jitter;
				float distanceToPoint = distFunc(pointPosition, localPosition);
				float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (smoothDistance - distanceToPoint) / smooth);
				float correctionFactor = smooth * h * (1.0 - h);
				smoothDistance = lerp(smoothDistance, distanceToPoint, h) - correctionFactor;
				correctionFactor /= 1.0 + 3.0 * smooth;
				float cellID = hash12(cellPosition + cellOffset);
				smoothID = lerp(smoothID, cellID, h) - correctionFactor;
				smoothPosition = lerp(smoothPosition, pointPosition, h) - correctionFactor;
			}
		}
		return cellPosition + smoothPosition;
	}


	// 3D
	worley3DFeature worleySmoothF1 (float3 p, float smooth = .2, float jitter = .7)
	{
		float3 cellPosition = floor(p);
		float3 localPosition = p - cellPosition;
		float smoothDistance  = 8.0;
		float3 smoothPosition = 0.0;
		float smoothID = 0.0;
		[unroll]
		for (int z = -1; z <= 1; z++) 
		{
			[unroll]
			for (int y = -1; y <= 1; y++) 
			{
				[unroll]
				for (int x = -1; x <= 1; x++) 
				{
					float3 cellOffset = float3(x, y, z);
					float3 pointPosition = cellOffset + hash33(cellPosition + cellOffset) * jitter;
					float distanceToPoint = distFunc(pointPosition, localPosition);
					float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (smoothDistance - distanceToPoint) / smooth);
					float correctionFactor = smooth * h * (1.0 - h);
					smoothDistance = lerp(smoothDistance, distanceToPoint, h) - correctionFactor;
					correctionFactor /= 1.0 + 3.0 * smooth;
					float cellID = hash13(cellPosition + cellOffset);
					smoothID = lerp(smoothID, cellID, h) - correctionFactor;
					smoothPosition = lerp(smoothPosition, pointPosition, h) - correctionFactor;
				}
			}
		}
		return makeWorleyFeature(smoothDistance, cellPosition + smoothPosition, smoothID);
	}

	// 4D
	worley4DFeature worleySmoothF1 (float4 p, float smooth = .2, float jitter = .7)
	{
		float4 cellPosition = floor(p);
		float4 localPosition = p - cellPosition;
		float smoothDistance  = 8.0;
		float4 smoothPosition = 0.0;
		float smoothID = 0.0;
		[unroll]
		for (int w = -1; w <= 1; w++) 
		{
			[unroll]
			for (int z = -1; z <= 1; z++) 
			{
				[unroll]
				for (int y = -1; y <= 1; y++) 
				{
					[unroll]
					for (int x = -1; x <= 1; x++) 
					{
						float4 cellOffset = float4(x, y, z, w);
						float4 pointPosition = cellOffset + hash44(cellPosition + cellOffset) * jitter;
						float distanceToPoint = distFunc(pointPosition, localPosition);
					
						float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (smoothDistance - distanceToPoint) / smooth);
						float correctionFactor = smooth * h * (1.0 - h);
						smoothDistance = lerp(smoothDistance, distanceToPoint, h) - correctionFactor;
						correctionFactor /= 1.0 + 3.0 * smooth;
						float cellID = hash14(cellPosition + cellOffset);
						smoothID = lerp(smoothID, cellID, h) - correctionFactor;
						smoothPosition = lerp(smoothPosition, pointPosition, h) - correctionFactor;
				
					}
				}
			}
		}
		return makeWorleyFeature(smoothDistance, cellPosition + smoothPosition, smoothID);
	}


};