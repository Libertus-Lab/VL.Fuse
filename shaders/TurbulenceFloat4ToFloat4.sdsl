shader TurbulenceFloat4ToFloat4 : Float4ToFloat4
{

    compose ComputeFloat gain;
    compose ComputeFloat octaves;
    compose ComputeFloat lacunarity;

    compose Float4ToFloat4 signal;

	float4 turbulence(float4 p){
		float4 noiseVal = abs(signal.Compute(p) - 0.5) * 2; 
 		noiseVal = pow(noiseVal , 1.);
		return noiseVal;
	}

    override float4 Compute(float4 p)
    {
        float myScale = 1;
        float myGain = gain.Compute();
        float myOctaves = octaves.Compute();
        float myLacunarity = lacunarity.Compute();

	    float myFallOff = myGain;

	    int iOctaves = int(floor(myOctaves)); 
	    float4 myResult = 0.;  
	    float myAmp = 0.;
	
	    for(int i = 0; i < iOctaves;i++){
		    myResult += turbulence(p * myScale) * myFallOff;
		    myAmp += myFallOff;
		    myFallOff *= myGain;
		    myScale *= myLacunarity;
	    }
	    float myBlend = myOctaves - float(iOctaves);
	
	    myResult += turbulence(p * myScale) * myFallOff * myBlend;    
	    myAmp += myFallOff * myBlend;
	
	    if(myAmp > 0.0){
		    myResult /= myAmp;
	    }
 
	    return myResult;
    }
};