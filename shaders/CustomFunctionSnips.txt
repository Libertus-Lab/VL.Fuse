// Euclidean
float ${signature} (float${Domain} a, float${Domain} b)
{
	return distance(a, b);
	// just use the intrisic function here.  N dimensional version below

	/*
    float result = 0.;
    for(int i = 0; i < ${Domain}; i++)
    {
 		result += ((a[i] - b[i]) * (a[i] - b[i]));
    }
    return sqrt(result);
    */
}

// EuclideanSquared
float ${signature} (float${Domain} a, float${Domain} b)
{
    float result = 0.;
    for(int i = 0; i < ${Domain}; i++)
    {
 		result += ((a[i] - b[i]) * (a[i] - b[i]));
    }
    return result;
}

// Manhattan
float ${signature} (float${Domain} a, float${Domain} b)
{
    float result = 0.;
    for(int i = 0; i < ${Domain}; i++)
    {
 		result += abs(a[i] - b[i]);
    }
    return result;
}

// Chebyshev
float ${signature} (float${Domain} a, float${Domain} b)
{
    float maxComponent = abs(a[0] - b[0]);
    for(int i = 1; i < ${Domain}; i++)
    {
 		float next = abs(a[i] - b[i]);
 		maxComponent = max(maxComponent, next);
    }
    return maxComponent;
}

// Canberra
float ${signature} (float${Domain} a, float${Domain} b)
{
    float result = 0.;
    for(int i = 0; i < ${Domain}; i++)
    {
 		result += abs(a[i] - b[i]) / (abs(a[i]) + abs(b[i]));
    }
    return result;
}


// CosineSimilarity
float ${signature} (float${Domain} a, float${Domain} b)
{
    float dotProduct = 0;
    float magnitudeOne = 0;
    float magnitudeTwo = 0;
    for(int i = 0; i < ${Domain}; i++)
    {
	    dotProduct += (a[i] * b[i]);
        magnitudeOne += (a[i] * b[i]);
        magnitudeTwo += (a[i] * b[i]);
    }
    return max(0, 1 - (dotProduct / sqrt(magnitudeOne * magnitudeTwo)));
}

// PearsonCorrelation
float ${signature} (float${Domain} a, float${Domain} b)
{
	float meanOne = 0.;
	float meanTwo = 0.;
	for(int i = 0; i < ${Domain}; i++)
    {
        meanOne += a[i];
        meanTwo += b[i];
    }
    meanOne /= ${Domain};
    meanTwo /= ${Domain};

    float covariance = 0;
    float standardDeviationOne = 0;
    float standardDeviationTwo = 0;
    for(int i = 0; i < ${Domain}; i++)
    {
        covariance += ((a[i] - meanOne) * (b[i] - meanTwo));
        standardDeviationOne += ((a[i] - meanOne) * (a[i] - meanOne));
        standardDeviationTwo += ((b[i] - meanTwo) * (b[i] - meanTwo));
    }
    return max(0, 1 - (covariance / sqrt(standardDeviationOne * standardDeviationTwo)));
}


// Minkowski
float ${signature} (float${Domain} a, float${Domain} b, float power = 4.)
{
	float result = 0.;
	for(int i = 0; i < ${Domain}; i++)
    {	
	 	result += pow(abs(a[i] - b[i]), power);
	}
	return pow(result, 1.0/ppwer);  
}



// sdf combine
Union
Intersect
Difference
UnionRound
IntersectionRound
DifferenceRound
UnionChamfer
IntersectionChamfer
DifferenceChamfer
UnionColumns
IntersectionColumns
DifferenceColumns
UnionStairs
IntersectionStairs
DifferenceStairs
Pipe
Engrave
Groove
Tongue

U(d1, d2)
I(d1, d2)
S(d1, d2)
fOpUnionRound(d1, d2, p1)
fOpIntersectionRound(d1, d2, p1)
fOpDifferenceRound(d1, d2, p1)
fOpUnionChamfer(d1, d2, p1)
fOpIntersectionChamfer(d1, d2, p1)
fOpDifferenceChamfer(d1, d2, p1)
fOpUnionColumns(d1, d2, p1, p2)
fOpIntersectionColumns(d1, d2, p1, p2)
fOpDifferenceColumns(d1, d2, p1, p2)
fOpUnionStairs(d1, d2, p1, p2)
fOpIntersectionStairs(d1, d2, p1, p2)
fOpDifferenceStairs(d1, d2, p1, p2)
fOpPipe(d1, d2, p1)
fOpEngrave(d1, d2, p1)
fOpGroove(d1, d2, p1, p2)
fOpTongue(d1, d2, p1, p2)


float ${signature}(${argumentType} p, float p1, float p2) 
{
	float d1 = ${sdf0}(p);
	float d2 = ${sdf1}(p);
	return ${OP};
}




//WorleySmooth
override float distFunc(${DOMAIN} x, ${DOMAIN} y)
{
	return ${DIST_FUNC}(x, y);
}

${FEATURE} ${signature} (float${DOMAIN} p, float smooth = .2, float jitter = .7)
{
	return worleySmoothF1(p, smooth, .7);
}