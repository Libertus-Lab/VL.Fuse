


// sdf combine
Union
Intersect
Difference
UnionRound
IntersectionRound
DifferenceRound
UnionChamfer
IntersectionChamfer
DifferenceChamfer
UnionColumns
IntersectionColumns
DifferenceColumns
UnionStairs
IntersectionStairs
DifferenceStairs
Pipe
Engrave
Groove
Tongue

U(d1, d2)
I(d1, d2)
S(d1, d2)
fOpUnionRound(d1, d2, p1)
fOpIntersectionRound(d1, d2, p1)
fOpDifferenceRound(d1, d2, p1)
fOpUnionChamfer(d1, d2, p1)
fOpIntersectionChamfer(d1, d2, p1)
fOpDifferenceChamfer(d1, d2, p1)
fOpUnionColumns(d1, d2, p1, p2)
fOpIntersectionColumns(d1, d2, p1, p2)
fOpDifferenceColumns(d1, d2, p1, p2)
fOpUnionStairs(d1, d2, p1, p2)
fOpIntersectionStairs(d1, d2, p1, p2)
fOpDifferenceStairs(d1, d2, p1, p2)
fOpPipe(d1, d2, p1)
fOpEngrave(d1, d2, p1)
fOpGroove(d1, d2, p1, p2)
fOpTongue(d1, d2, p1, p2)


float ${signature}(${argumentType} p, float p1, float p2) 
{
	float d1 = ${sdf0}(p);
	float d2 = ${sdf1}(p);
	return ${OP};
}





//WorleySmooth
override float distFunc(${DOMAIN} a, ${DOMAIN} b)
{
	return ${DIST_FUNC}(a, b);
}

float ${signature} (${DOMAIN} p, out ${DOMAIN} cellPosition, out float cellID, float smooth, float jitter)
{
	return worleySmoothF1(p, cellPosition,  cellID, smooth, jitter);
}




// raymarcher
float SDF(float3 p) // should be override unless it's the first imp.  Gets called by the other functions
{
	return ${SDF}(p);
}

void killRay() { ${KILL}(); }

float4 ${signature}(float3 p, int maxIter)
{
	Ray ray = ${SETUP}();
	float2 minMaxDist = ${CULL}(ray);
	${MARCH}(ray, minMaxDist, maxIter);
	ray.sn = SDFNormal(ray.sp);
	return ${SHADE}(ray);
}



// this was the shader code, note just the first arg gets passed on:
float DIST_FUNC62600255(float2 arg_val57212719, float2 arg_val3718701)
{
    float result_13813509 = DistanceMetric63077346(arg_val57212719, arg_val57212719);

    return result_13813509;
}